// -*- mode: dts; tab-width: 2; -*-
#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#define HOST_OS 2
#include "zmk-helpers/helper.h"

ZMK_UNICODE_SINGLE(euro_sign,                 N2, N0,  A,  C)   // €  EURO SIGN
ZMK_UNICODE_SINGLE(degree_symbol,             N0, N0,  B, N0)   // °  DEGREE SIGN
ZMK_UNICODE_SINGLE(prime,                     N2, N0, N3, N2)   // ′  PRIME
ZMK_UNICODE_SINGLE(double_prime,              N2, N0, N3, N3)   // ″  DOUBLE PRIME
ZMK_UNICODE_SINGLE(en_dash,                   N2, N0, N1, N3)   // –  EN DASH
ZMK_UNICODE_SINGLE(em_dash,                   N2, N0, N1, N4)   // —  EM DASH
ZMK_UNICODE_SINGLE(triangular_bullet,         N2, N0, N2, N3)   // ‣  TRIANGULAR BULLET
ZMK_UNICODE_SINGLE(left_single_quote,         N2, N0, N1, N8)   // ‘  LEFT SINGLE QUOTATION MARK
ZMK_UNICODE_SINGLE(right_single_quote,        N2, N0, N1, N9)   // ’  RIGHT SINGLE QUOTATION MARK
ZMK_UNICODE_SINGLE(left_double_quote,         N2, N0, N1,  C)   // “  LEFT DOUBLE QUOTATION MARK
ZMK_UNICODE_SINGLE(right_double_quote,        N2, N0, N1,  D)   // ”  RIGHT DOUBLE QUOTATION MARK
ZMK_UNICODE_SINGLE(multiplication_sign,       N0, N0,  D, N7)   // ×  MULTIPLICATION SIGN
ZMK_UNICODE_SINGLE(division_sign,             N0, N0,  F, N7)   // ÷  DIVISION SIGN
ZMK_UNICODE_SINGLE(for_all,                   N2, N2, N0, N0)   // ∀  FOR ALL
ZMK_UNICODE_SINGLE(there_exists,              N2, N2, N0, N3)   // ∃  THERE EXISTS
ZMK_UNICODE_SINGLE(empty_set,                 N2, N2, N0, N5)   // ∅  EMPTY SET
ZMK_UNICODE_SINGLE(element_of,                N2, N2, N0, N8)   // ∈  ELEMENT OF
ZMK_UNICODE_SINGLE(qed_motherfucker,          N2, N2, N0,  E)   // ∎  END OF PROOF
ZMK_UNICODE_SINGLE(product,                   N2, N2, N0,  F)   // ∏  N-ARY PRODUCT
ZMK_UNICODE_SINGLE(sum,                       N2, N2, N1, N1)   // ∑  N-ARY SUMMATION
ZMK_UNICODE_SINGLE(ring,                      N2, N2, N1, N8)   // ∘  RING OPERATOR
ZMK_UNICODE_SINGLE(proportional,              N2, N2, N1,  D)   // ∝  PROPORTIONAL TO
ZMK_UNICODE_SINGLE(infinity,                  N2, N2, N1,  E)   // ∞  INFINITY
ZMK_UNICODE_SINGLE(logical_and,               N2, N2, N2, N7)   // ∧  LOGICAL AND
ZMK_UNICODE_SINGLE(logical_or,                N2, N2, N2, N8)   // ∨  LOGICAL OR
ZMK_UNICODE_SINGLE(intersection,              N2, N2, N2, N9)   // ∩  INTERSECTION
ZMK_UNICODE_SINGLE(union,                     N2, N2, N2,  A)   // ∪  UNION
ZMK_UNICODE_SINGLE(almost_equal,              N2, N2, N4, N8)   // ≈  ALMOST EQUAL TO
ZMK_UNICODE_SINGLE(less_than_or_equal,        N2, N2, N6, N4)   // ≤  LESS-THAN OR EQUAL TO
ZMK_UNICODE_SINGLE(greater_than_or_equal,     N2, N2, N6, N5)   // ≥  GREATER-THAN OR EQUAL TO
ZMK_UNICODE_SINGLE(identical_to,              N2, N2, N6, N1)   // ≡  IDENTICAL TO
ZMK_UNICODE_SINGLE(box_upperleft,             N2, N5, N6,  D)   // ╭  BOX DRAWINGS LIGHT ARC DOWN AND RIGHT
ZMK_UNICODE_SINGLE(box_upperright,            N2, N5, N6,  E)   // ╮  BOX DRAWINGS LIGHT ARC DOWN AND LEFT
ZMK_UNICODE_SINGLE(box_lowerright,            N2, N5, N6,  F)   // ╯  BOX DRAWINGS LIGHT ARC UP AND LEFT
ZMK_UNICODE_SINGLE(box_lowerleft,             N2, N5, N7, N0)   // ╰  BOX DRAWINGS LIGHT ARC UP AND RIGHT
ZMK_UNICODE_SINGLE(box_horizontal,            N2, N5, N0, N0)   // ─  BOX DRAWINGS LIGHT HORIZONTAL
ZMK_UNICODE_SINGLE(box_vertical,              N2, N5, N0, N2)   // │  BOX DRAWINGS LIGHT VERTICAL
ZMK_UNICODE_SINGLE(box_middle,                N2, N5, N3,  C)   // ┼  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
ZMK_UNICODE_SINGLE(box_middlebottom,          N2, N5, N3, N4)   // ┴  BOX DRAWINGS LIGHT UP AND HORIZONTAL
ZMK_UNICODE_SINGLE(box_middletop,             N2, N5, N2,  C)   // ┬  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
ZMK_UNICODE_SINGLE(box_middleright,           N2, N5, N2, N4)   // ┤  BOX DRAWINGS LIGHT VERTICAL AND LEFT
ZMK_UNICODE_SINGLE(box_middleleft,            N2, N5, N1,  C)   // ├  BOX DRAWINGS LIGHT VERTICAL AND RIGHT


// tap: sticky-shift | shift + tap/ double-tap: caps-word | hold: shift
ZMK_BEHAVIOR(smart_shft, mod_morph,
    bindings = <&sk LSHFT>, <&caps_word>;
    mods = <(MOD_LSFT)>;
)
&caps_word {  // mods deactivate caps-word, requires PR #1451
    /delete-property/ ignore-modifiers;
};

ZMK_COMBO(combo_caps_word, &caps_word, 17 20, ALL, 25)

// reuse basic mod-morph scheme
#define SIMPLE_MORPH(NAME, MOD, BINDING1, BINDING2) \
    ZMK_MOD_MORPH(NAME, \
        mods = <(MOD_L ## MOD|MOD_R ## MOD)>; \
        bindings = <BINDING1>, <BINDING2>; \
    )

// tap: colon | shift + tap: semicolon
SIMPLE_MORPH(colonsemi, SFT, &kp COLON, &kp SEMI)

#define KEYS_L 0 1 2 3 4 5 12 13 14 15 16 17 24 25 26 27 28 29   // left hand
#define KEYS_R 6 7 8 9 10 11 18 19 20 21 22 23 30 31 32 33 34 35 // right hand
#define THUMBS 36 37 38 39 40 41 42 43 44 45 46 47               // thumbs
#define QUICK_TAP_MS 175

#define MAKE_HRM(NAME, HOLD, TAP, TRIGGER_POS) \
    ZMK_HOLD_TAP(NAME, \
        flavor = "balanced"; \
        tapping-term-ms = <280>; \
        quick-tap-ms = <QUICK_TAP_MS>; \
        require-prior-idle-ms = <150>; \
        bindings = <HOLD>, <TAP>; \
        hold-trigger-key-positions = <TRIGGER_POS>; \
        hold-trigger-on-release; \
    )
MAKE_HRM(hml, &kp, &kp, KEYS_R THUMBS)  // left-hand HRMs
MAKE_HRM(hmr, &kp, &kp, KEYS_L THUMBS)  // right-hand HRMs

//MAKE_HRM(hml_repeat, &kp, &key_repeat, KEYS_R THUMBS)  // used for HRM-combo
//MAKE_HRM(hmr_lpar_lt, &kp, &lpar_lt, KEYS_L THUMBS)    // "    "   "   "
//MAKE_HRM(hmr_rpar_gt, &kp, &rpar_gt, KEYS_L THUMBS)    // "    "   "   "

ZMK_BEHAVIOR(flip_buffer, macro,
    wait-ms = <100>;
    tap-ms = <5>;
    bindings = <&kp LC(X) &kp B &kp RET>;
)

//  0  1  2  3  4  5     6  7  8  9 10 11 12
// 13 14 15 16 17 18    19 20 21 22 23 24 25
// 26 27 28 29 30 31    32 33 34 35 36 37 38

// index on r u in FN layer within 100 milliseconds
ZMK_COMBO(startbootloader,  &bootloader, 4 7, 4, 100)

// GUIDO: This doesn't work because of the home-row-mods
// ZMK_COMBO(movelayer, &mo 7, 16 17, ALL, 50)
